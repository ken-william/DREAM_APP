# =====================================================
# WORKFLOW CI/CD - SYNTHÃ‰TISEUR DE RÃŠVES (SQLite)
# =====================================================
# Version optimisÃ©e pour SQLite - Plus simple et fiable
# Conforme aux exigences du cahier des charges

name: ğŸš€ CI/CD Pipeline - Dream Synthesizer (SQLite)

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

env:
  PYTHON_VERSION: '3.12'
  NODE_VERSION: '18'

jobs:
  # =====================================================
  # JOB 1: TESTS BACKEND DJANGO (SQLite)
  # =====================================================
  test-backend:
    runs-on: ubuntu-latest
    name: ğŸ§ª Tests Backend Django (SQLite)
    
    # PAS de service PostgreSQL - on utilise SQLite !
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ Setup Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: ğŸ“¦ Cache Dependencies
      uses: actions/cache@v3
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements-sqlite.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-

    - name: ğŸ”§ Install Dependencies (SQLite version)
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements-sqlite.txt

    - name: ğŸ” Setup Environment Variables (SQLite)
      run: |
        echo "DJANGO_SECRET_KEY=${{ secrets.DJANGO_SECRET_KEY }}" >> $GITHUB_ENV
        # PAS de DATABASE_URL = utilise SQLite par dÃ©faut
        echo "DEBUG=False" >> $GITHUB_ENV
        echo "GROQ_API_KEY=${{ secrets.GROQ_API_KEY }}" >> $GITHUB_ENV
        echo "HUGGINGFACE_API_KEY=${{ secrets.HUGGINGFACE_API_KEY }}" >> $GITHUB_ENV

    - name: ğŸ—ƒï¸ Run Migrations (SQLite)
      working-directory: ./backend
      run: |
        python manage.py makemigrations
        python manage.py migrate
        # SQLite DB crÃ©Ã©e automatiquement

    - name: ğŸ§ª Run Django Tests
      working-directory: ./backend
      run: |
        python manage.py test --verbosity=2

    - name: ğŸ” Django Check
      working-directory: ./backend
      run: |
        python manage.py check --deploy

    - name: ğŸ“Š Code Coverage
      working-directory: ./backend
      run: |
        coverage run --source='.' manage.py test
        coverage report --show-missing
        coverage xml

    - name: ğŸ“ˆ Upload Coverage to Codecov
      uses: codecov/codecov-action@v3
      with:
        file: ./backend/coverage.xml
        flags: backend
        name: backend-coverage

  # =====================================================
  # JOB 2: TESTS FRONTEND REACT
  # =====================================================
  test-frontend:
    runs-on: ubuntu-latest
    name: âš›ï¸ Tests Frontend React
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸŸ¢ Setup Node.js ${{ env.NODE_VERSION }}
      uses: actions/setup-node@v4
      with:
        node-version: ${{ env.NODE_VERSION }}
        cache: 'npm'
        cache-dependency-path: frontend/package-lock.json

    - name: ğŸ“¦ Install Dependencies
      working-directory: ./frontend
      run: npm ci

    - name: ğŸ§ª Run Tests
      working-directory: ./frontend
      run: npm run test -- --coverage --passWithNoTests

    - name: ğŸ—ï¸ Build React App
      working-directory: ./frontend
      run: npm run build

    - name: ğŸ“ˆ Upload Coverage
      uses: codecov/codecov-action@v3
      with:
        file: ./frontend/coverage/coverage-final.json
        flags: frontend
        name: frontend-coverage

  # =====================================================
  # JOB 3: ANALYSE QUALITÃ‰ CODE
  # =====================================================
  code-quality:
    runs-on: ubuntu-latest
    name: ğŸ” Analyse QualitÃ© Code
    needs: [test-backend, test-frontend]
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}

    - name: ğŸ”§ Install Code Quality Tools
      run: |
        pip install flake8 black pylint bandit safety

    - name: ğŸ¨ Check Code Formatting (Black)
      run: |
        black --check --diff backend/

    - name: ğŸ“ Lint Code (Flake8)
      run: |
        flake8 backend/ --count --select=E9,F63,F7,F82 --show-source --statistics
        flake8 backend/ --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

    - name: ğŸ”’ Security Check (Bandit)
      run: |
        bandit -r backend/ -f json -o bandit-report.json
      continue-on-error: true

    - name: ğŸ›¡ï¸ Dependency Security Check
      run: |
        safety check --json --output safety-report.json
      continue-on-error: true

  # =====================================================
  # JOB 4: BUILD & DEPLOY STAGING (SQLite)
  # =====================================================
  deploy-staging:
    runs-on: ubuntu-latest
    name: ğŸš€ Deploy Staging (SQLite)
    needs: [test-backend, test-frontend, code-quality]
    if: github.ref == 'refs/heads/develop'
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ—ï¸ Build Application (SQLite)
      run: |
        echo "Building application for staging with SQLite..."
        # Utiliser docker-compose-sqlite.yml
        
    - name: ğŸ³ Build Docker Image (SQLite)
      run: |
        docker build -f Dockerfile-sqlite -t dream-synthesizer:staging .

    - name: ğŸš€ Deploy to Staging
      run: |
        echo "Deploying SQLite version to staging..."
        # Le dÃ©ploiement utilisera SQLite par dÃ©faut

  # =====================================================
  # JOB 5: DEPLOY PRODUCTION (SQLite)
  # =====================================================
  deploy-production:
    runs-on: ubuntu-latest
    name: ğŸŒŸ Deploy Production (SQLite)
    needs: [test-backend, test-frontend, code-quality]
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸ—ï¸ Build for Production (SQLite)
      run: |
        echo "Building application for production with SQLite..."

    - name: ğŸ³ Build Production Image
      run: |
        docker build -f Dockerfile-sqlite -t dream-synthesizer:production .

    - name: ğŸš€ Deploy to Production (Railway/Heroku)
      run: |
        echo "Deploying SQLite version to production..."
        # Le dÃ©ploiement se fera avec SQLite par dÃ©faut
        # Plus simple = plus fiable !

    - name: ğŸ”” Notify Success
      if: success()
      run: |
        echo "âœ… SQLite Deployment successful!"

    - name: ğŸš¨ Notify Failure
      if: failure()
      run: |
        echo "âŒ Deployment failed!"

  # =====================================================
  # JOB 6: TESTS POST-DÃ‰PLOIEMENT
  # =====================================================
  post-deploy-tests:
    runs-on: ubuntu-latest
    name: ğŸ¯ Tests Post-DÃ©ploiement (SQLite)
    needs: [deploy-production]
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: ğŸ“¥ Checkout Code
      uses: actions/checkout@v4

    - name: ğŸŒ Health Check API
      run: |
        # Test de santÃ© sur l'API avec SQLite
        curl -f https://votre-app.herokuapp.com/health/ || exit 1

    - name: ğŸ§ª Smoke Tests (SQLite)
      run: |
        echo "Running smoke tests on SQLite production..."
        # Tests rapides pour vÃ©rifier SQLite fonctionne

    - name: ğŸ“§ Send Success Notification
      if: success()
      run: |
        echo "ğŸ‰ Dream Synthesizer (SQLite) deployed successfully!"

# =====================================================
# AVANTAGES VERSION SQLITE :
# - Plus simple (pas de service PostgreSQL)
# - Plus rapide (pas d'attente DB)
# - Plus fiable (moins de dÃ©pendances)
# - IdÃ©al pour contexte acadÃ©mique
# =====================================================
